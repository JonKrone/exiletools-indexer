// This is an initial proof of concept.
// Eventually this program will be built into a full JSON re-formatted for Path of Exile
// Item Documents
//
// Right now, it uses Kafka to pull *sample* data from the live Indexer partition
// At some point, we'll have to change this to test cases instead. This is just
// the fastest way to get up and running.

// Initial variables
var _ = require('lodash');
var Kafka = require('no-kafka');
var consumer = new Kafka.SimpleConsumer();
var dt = require("dotty");
var prettyHrtime = require('pretty-hrtime');

// ========================================
// Read in JSON data files
// ========================================
// Manually Generated
var frameTypeToRarity = require('./data/frameType-to-Rarity.json');
// Generate with "bin/tools/pull-item-data-from-poedb.pl json"
var baseItemNameToBaseItemType = require('./data/baseItemName-to-baseItemType.json');
// Generate with "pull-map-names-from-poedb.pl json > ../../v5node/data/itemNamesMaps.json"
var itemNamesMaps = require('./data/itemNamesMaps.json');
// Generated by hand
var itemNamesJewels = require('./data/itemNamesJewels.json');

// Local settings for short circuiting
var processedCount = 0, maxToProcess = 100;

// Iterate the Kafka stash data
var dataHandler = function (messageSet, topic, partition) {
  var timeProcessStart = process.hrtime(); // Set a timer
  messageSet.forEach(function (m) {
    processedCount++;
    if (processedCount > maxToProcess) {
      var timeProcessEnd = process.hrtime(timeProcessStart);
      var prettyTime = prettyHrtime(timeProcessEnd);
      console.log(maxToProcess + " stashes processed in " + prettyTime);
      process.exit(0);
    }
    // turn this stash into a JSON object named item so we can reference it
    var stash = JSON.parse(m.message.value.toString('utf8'));
//    console.log("This Stash: " + stash.stash);  

    // Iterate through each item in the stash
    stash.items.forEach(function (item) {
      processItem(item,stash);
    });
  });
};

// ========================================
// This is the core function that actually processes item JSON data
// ========================================
function processItem(item,stash) {
  var e = new Object(); // This represents the Elasticsearch formatted JSON data. On a separate line for clarity.

  e.uuid = item.id;

  // Begin by setting fixed data from item, note all items at this point are verified as YES
  e.shop = { sellerAccount:stash.accountName, lastCharacterName:stash.lastCharacterName, note:item.note, verified:"YES" };
  e.shop.stash = { stashID:stash.id, stashName:stash.stash, inventoryID:item.inventoryId, xLocation:item.x, yLocation:item.y };
  e.attributes = { inventoryWidth:item.w, intentoryHeight:item.h, league:item.league, identified:item.identified, corrupted:item.corrupted, ilvl:item.ilvl, frameType:item.frameType, rarity:frameTypeToRarity[item.frameType] };
  e.info = { name:item.name }; // note we set an empty name and typeLine if they don't exist, that's ok, these fields confuse people

  // These are sections that we only want to set if it exists in the original data
  if (item.support) { e.attributes.support = item.support };
  if (item.talismanTier > 0) { e.attributes.talismanTier = item.talismanTier };
  if (item.descrText) { e.info.descrText = item.descrText };
  if (item.prophecyText) { e.info.prophecyText = item.prophecyText };
  if (item.duplicated) { e.attributes.mirrored = item.duplicated };

  // Some fields that we populate need to be cleaned up a bit while we set them
  e.info.icon = item.icon.replace(/\?.*$/, '');  // Remove junk from URL
  e.info.typeLine = item.typeLine.replace(/^(Superior |\s+)/, '');  // Remove leading Superior or whitespace from typeLine

  // Setting the item's full name is a bit confusing because we have two fields
  // that may or may not exist and may comprise bits of the name, so I'm using
  // an if statement to join them to avoid unecessary spaces
  if (item.name && item.typeLine) {
    e.info.fullName = (item.name + " " + item.typeLine);
  } else if (item.name) {
    e.info.fullName = item.name;
  } else if (item.typeLine) {
    e.info.fullName = item.typeLine;
  }

  // Call a function to identify the item type
  identifyItemTypes(item,e);

//  if (e.attributes.itemType === "Jewel" && e.attributes.rarity === "Magic") {
//    console.log(JSON.stringify(e, null, ' '));
//  }
};

// ========================================
// This subroutine should set the itemType, baseItemType, baseItemName, and equipType where applicable for items
// ========================================
function identifyItemTypes(item,e) {
  // Some of these can be done based only on the frameType, so get them out of the way first
  // GEMS
  if (item.frameType === 4) {
    e.attributes.itemType = "Gem";
    e.attributes.baseItemType = "Gem";
    e.attributes.baseItemName = e.info.fullName;
    e.attributes.equipType = "Gem";
    return;
  }
  // CURRENCY
  if (item.frameType === 5) {
    e.attributes.itemType = "Currency";
    e.attributes.baseItemType = "Currency";
    e.attributes.baseItemName = e.info.fullName;
    e.attributes.equipType = "Currency";
    return;
  }
  // DIVINATION CARDS
  if (item.frameType === 6) {
    e.attributes.itemType = "Card";
    e.attributes.baseItemType = "Card";
    e.attributes.baseItemName = e.info.fullName;
    e.attributes.equipType = "Card";
    return;
  }
  // Quest Items - we index these just in case
  if (item.frameType === 7) {
    e.attributes.itemType = "Quest Item";
    e.attributes.baseItemType = "Quest Item";
    e.attributes.baseItemName = e.info.fullName;
    e.attributes.equipType = "Quest Item";
    return;
  }
  // Prophecy
  if (item.frameType === 8) {
    e.attributes.itemType = "Prophecy";
    e.attributes.baseItemType = "Prophecy";
    e.attributes.baseItemName = e.info.fullName;
    e.attributes.equipType = "Prophecy";
    return;
  }
  
  // Types 0-3 need to be analyzed in more depth, because the frameType for them just indicates
  // what "level" of mods the item has (i.e. normal, magic, rare) and doesn't actually tell us
  // anything else about the item, unlike types 4+. This is because the frameType's purpose
  // is really just to show a color or something. 

  // IMPORTANT: I think I need to change indexOf to a word boundary based regexp. I know this
  // has caused problems in the past, i.e. "Sai" vs "Saintly Chainmail"
  if (item.frameType < 4) {
    // Is it a Map?
    if (item.descrText && item.descrText.indexOf('Travel to this Map by using it in the Eternal Laboratory') >= 0) {
      e.attributes.itemType = "Map";
      e.attributes.baseItemType = "Map";
      e.attributes.equipType = "Map";
      if (itemNamesMaps.indexOf(e.info.typeLine) >= 0) {
        e.attributes.baseItemName = e.info.typeLine;
      } else if (itemNamesMaps.indexOf(e.info.fullName) >= 0) {
        e.attributes.baseItemName = e.info.fullName;
      } else if (itemNamesMaps.some(function(myVal) { if (e.info.fullName.indexOf(myVal) >= 0) { e.attributes.baseItemName = myVal; return true }; })) {
        // The baseItemName was set in the above some function
      } else {
        console.log('-- UNKNOWN BASE TYPE! --');
        console.log(JSON.stringify(item,null,' '));
        console.log(JSON.stringify(e,null,' '));
        console.log('-----');
      }
      return;
    } else if (item.descrText && item.descrText.indexOf('Place into an allocated Jewel Socket') >= 0) {
      e.attributes.itemType = "Jewel";
      e.attributes.baseItemType = "Jewel";
      e.attributes.equipType = "Jewel";
      if (itemNamesJewels.indexOf(e.info.typeLine) >= 0) {
        e.attributes.baseItemName = e.info.typeLine;
      } else if (itemNamesJewels.indexOf(e.info.fullName) >= 0) {
        e.attributes.baseItemName = e.info.fullName;
      } else if (itemNamesJewels.some(function(myVal) { if (e.info.fullName.indexOf(myVal) >= 0) { e.attributes.baseItemName = myVal; return true }; })) {
        // The baseItemName was set in the above some function
      } else {
        console.log('-- UNKNOWN BASE TYPE! --');
        console.log(JSON.stringify(item,null,' '));
        console.log(JSON.stringify(e,null,' '));
        console.log('-----');
      }
      return;
    }

  }


};


// KAFKA DATA HANDLER FUNCTION - must be at the end!

// Grab some data from Kafka
return consumer.init().then(function () {
  return consumer.subscribe('incoming', 0, {time: Kafka.EARLIEST_OFFSET, maxBytes: 252600000, maxWaitTime: 20}, dataHandler);
});

